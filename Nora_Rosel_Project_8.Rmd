---
title: "Nora_Rosel_Project_8"
output: html_document
date: "2024-05-07"
---

```{r}
install.packages(c("ggbiplot", "rgl", "biomaRt", "ggplot2", "ggrepel", "pheatmap"))
```
```{r setup, include=FALSE}

knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache =TRUE)
knitr::opts_chunk$set(fig.width=16, fig.height=10, figure.align = "center") 
rm(list = ls())


if (!require("BiocManager", quietly = TRUE))
  BiocManager::install("BiocManager")
if (!require("DESeq2", quietly = TRUE))
  BiocManager::install("DESeq2")
library("DESeq2")
if (!require("ape", quietly = TRUE))
  BiocManager::install("ape")
library("ape")
if (!require("limma", quietly = TRUE))
  BiocManager::install("limma")
library("limma")
if (!require("geneplotter", quietly = TRUE))
  BiocManager::install("geneplotter")
library("geneplotter")
if (!require("gprofiler2", quietly = TRUE))
  BiocManager::install("gprofiler2")
library("gprofiler2")
if (!require("edgeR", quietly = TRUE))
  BiocManager::install("edgeR")
library("edgeR")

#From the provided code by the paper:

#RNA-seq pipeline for analyzing salmon aligned quant.sf files.
#Will perform normalization and differential expression analysis.
#Outputs abundance (TPM) file, count file, LFC files indicated in the conditions input,
#write GSEA files (.rnk), make volcano plots for each LFC file, make PCA graph for all input data

#run in the folder with all the .sf files and conditions file input with the format: (Sample, Condition, OutputFileName)
#sample names will be the same as the filenames without the .sf extension.
#LFC analyses are separated by unique outputfilenames.

# A .sf file typically refers to a file format used in the context of RNA sequencing (RNA-seq) data, particularly with the Salmon tool. Salmon is a software tool for quantifying the expression of transcripts from RNA-seq data. The .sf files generated by Salmon contain transcript-level quantification data.

library("DESeq2")
library("ggplot2")
library("ggrepel")
library("dplyr")

```


## Load data

```{r}

conditionsfile_path <- "C:/Users/norar/OneDrive/Documentos/EPFL/BA/Genomics and bioinformatics/Project/Group 8/student_files/SF268_features.csv"
RNAcountFile_path <- "C:/Users/norar/OneDrive/Documentos/EPFL/BA/Genomics and bioinformatics/Project/Group 8/student_files/SF268_neratinib_counts.csv"
conditionsfile_path_TS <- "C:/Users/norar/OneDrive/Documentos/EPFL/BA/Genomics and bioinformatics/Project/Group 8/student_files/TS895_features.csv"
RNAcountFile_path_TS <- "C:/Users/norar/OneDrive/Documentos/EPFL/BA/Genomics and bioinformatics/Project/Group 8/student_files/TS895_neratinib_counts.csv"

#For visualization outside of the function.

conditionsfile <- read.csv(conditionsfile_path)
RNAcountfile <- read.csv(RNAcountFile_path)
conditionsfile_TS <- read.csv(conditionsfile_path_TS)
RNAcountfile_TS <- read.csv(RNAcountFile_path_TS)

```


## From the provided code

```{r}

#Purpose: Main function to execute the RNA-seq analysis pipeline. 
#Parameters:
#conditionsfile: Path to the conditions file containing metadata for the samples.
#RNAcountFile: Pre-analyzed RNA count data file.
#pca: (Default: TRUE) Flag to perform PCA.

RNAseq.Pipeline<-function(conditionsfile_path, RNAcountFile_path, pca = TRUE) {
  
  #  I deleted this section because we know for sure that we have a RNAcountFile, therefore it's not necessary.
  # 
  #  if (is.null(RNAcountFile) == TRUE) {   #allows running pipeline on pre-analyzed count data.
  # 
  #   rnaData <- RNApipeline.salmon.process()   
  # 
  #   rnaData <- read.table("salmongene_counts.txt", sep = "\t", header = T)
  # 
  # } else {
  # 
  #   rnaData <- read.table(RNAcountFile, sep = "\t", header = T)
  # 
  # }
  
  #Processes quant.sf files to counts.
  rnaData <- read.csv(RNAcountFile_path, header = TRUE)
  
  #Checks for duplicated genes in the counts file, deletes the following entries if found.
  duplicatedGenes <- which(duplicated(rnaData[,1]) == T)
  if (length(duplicatedGenes) > 0) {
    print("Duplicate ENSGs. Deleted entries:")
    print(rnaData[duplicatedGenes,1:2])
    rnaData <- rnaData[-duplicatedGenes,]
  }
  
  rownames(rnaData) <- rnaData[,1]   #makes rownames the unique ensembl gene ID
  geneKey <- rnaData[,1:2]
  
  # I deleted this section because again we have a RNAcountFile, and we don't have OutputFileName for defining listAnalysis.
  #
  # reorganizes data, makes pca groups table, and makes PCA graph
  # 
  # if (pca == TRUE && is.null(RNAcountFile) == TRUE) {
  # 
  #   PCAdata <- read.table("salmongene_abundance.txt", sep = "\t", header = T)
  # 
  #   PCAdata <- PCAdata[,-1:-2]
  # 
  #   RNAsamples <- colnames(PCAdata)
  # 
  #   labelsdf <- t(as.data.frame(strsplit(RNAsamples, "_")))
  # 
  #   PCAsamples <- paste(labelsdf[,3], labelsdf[,4], labelsdf[,5], sep = "_")
  # 
  #   colnames(PCAdata) <- PCAsamples
  # 
  #   PCAconditions <- data.frame(Samples = PCAsamples, 
  # 
  #                               Condition = factor(paste(labelsdf[,2], labelsdf[,3], sep = "_")))
  # 
  #   RNApipeline.pca(PCAdata, PCAconditions)
  # 
  # }
  # 
  # conditionsdf <- read.table(conditionsfile, sep = "\t", header = T)
  # determines number of analyses for deseq loop
  # listAnalysis <- levels(conditionsdf$OutputFileName)
  
  
  #Differential expression analysis begins here.
  
  conditionsdf <- read.csv(conditionsfile_path, header = T)
  
  #Determines number of analyses for deseq loop, we don't have OutputFileName, so:
  listAnalysis <- unique(conditionsdf$time)
  
  #I took the "untreated" outside of the loop, because it was printing the same thing twice.
  untreatedSamples <- conditionsdf$sample[conditionsdf$time == "0H"]
  untreatedCols <- match(untreatedSamples, colnames(rnaData))
  print(paste("untreatedCols", toString(untreatedCols)))
  
  #I initialize the dataframes to store top genes, for later usage.
  top_upregulated_genes_df <- data.frame()
  top_downregulated_genes_df <- data.frame()
  
  #This loop performs all the differential analysis specified in the conditions file.
  for (i in listAnalysis[-1]) {
    
    #Gets RNAdata columns for samples in the i-th analysis (6H or 72H).
    
    treatedSamples <- conditionsdf$sample[conditionsdf$time == i]
    treatedCols <- match(treatedSamples, colnames(rnaData))
    print(paste("treatedCols", toString(treatedCols)))
    
    
    #Creates a RNA data subset dataframe for each analysis.
    tempRNAdata <- as.matrix(subset(rnaData, select = c(treatedCols, untreatedCols)))
    
    #I deleted these lines because we don't have OutputFileName and the colnames don't match ours.
    #
    # conditions <- conditionsdf[which(conditionsdf$OutputFileName == i),1:2]
    # 
    # conditions <- conditions[match(colnames(tempRNAdata), conditions$Sample),]
    # 
    # colnames(conditions) <- c("sample", "condition")

    
    #I prepare conditions file for DESeq2. I want to keep first and fourth columns, first is sample and fourth time.
    conditions <- conditionsdf[which(conditionsdf$time == i | conditionsdf$time == "0H"),c(1,4)] 
    conditions <- conditions[match(colnames(tempRNAdata), conditions$sample),]
    print(conditions)
    colnames(conditions) <- c("sample", "time")
    
    
    #Performs differential expression.
    RNAlfc <- RNApipeline.DESeq2(tempRNAdata, conditions, geneKey)
    print(RNAlfc)
    
    #These lines are commented out in this part, because we don't need a rnk file.
    #
    #writes LFC and gsea files
    # write.table(RNAlfc, paste(i, ".txt", sep = ""), sep = "\t", col.names = T, row.names = F, quote = F)
    # 
    # write.table(subset(RNAlfc, select = c(2,4)), paste(i, "_GSEA.rnk", sep = ""), sep = "\t", col.names = F, row.names = F, quote = F)

    #Makes volcano plot.
    top_genes <- RNApipeline.volcano.plot(RNAlfc, alphavalue = 0.05, graphname = paste("volcano_", i, "h_vs_0h", sep = ""), topgenes = 20)
    
    #Appends results to top genes dataframes.
    top_upregulated_genes_df <- rbind(top_upregulated_genes_df, 
                                      data.frame(time = paste0(i, "h"), top_genes$top_upregulated))
    top_downregulated_genes_df <- rbind(top_downregulated_genes_df, 
                                        data.frame(time = paste0(i, "h"), top_genes$top_downregulated))
  }
  
  #Returns the lists of top genes.
  return(list(upregulated = top_upregulated_genes_df, downregulated = top_downregulated_genes_df))
    
}

#These functions weren't used, because I didn't need them: RNApipeline.salmon.process<-function(), or RNApipeline.pca<-function(pcaData, pcaGroups)

```

```{r}

#Performs differential expression analysis using DESeq2. Key Steps:

#Creates a DESeqDataSet object from the count data and conditions.
#Prefilters low count features.
#Runs DESeq2 analysis to compute differentially expressed genes.
#Returns a data frame with log fold change and p-values, ordered by significance.

#input selected RNA seq data matrix and conditions dataframe with no extraneous data
#will run differential expression using the conditions dataframe and will return the LFC dataframe

RNApipeline.DESeq2<-function(tempRNAdata, conditions, geneKey) {
  
  #I modified design, deleted condition and put time.
  dds <- DESeqDataSetFromMatrix(countData = tempRNAdata, colData = conditions, design = ~ time)
  print(dds$time)
  
  #Prefiltering removes low count features of < 10 reads for a row of a feature.
  keep <- rowSums(counts(dds)) >= 10
  dds <- dds[keep,]
  
  #This line was changed, as we are using time instead of condition.
  #dds$condition <- factor(dds$condition, levels = c("untreated","treated"))
  
  #Factor leveling.
  levels_in_conditions <- unique(conditions$time)
  dds$time <- factor(dds$time, levels = rev(levels_in_conditions))
  print(dds$time)
  
  #I deleted this line, because we aren't using condition. 
  # res <- results(dds, contrast=c("condition","treated","untreated"))
  # summary(res)
  
  #Differential expression calculation.
  dds <- DESeq(dds)
  res <- results(dds)
  resOrdered <- res[order(res$pvalue),]
  resOrdered <- data.frame(GeneID = rownames(resOrdered), GeneSymbol = geneKey[match(rownames(resOrdered), geneKey$GeneID), "GeneSymbol"], resOrdered)
  return(resOrdered)
}

```

```{r}

# Makes volcanoplot.
# limsPercentile uses input percentile to tag outliers and convert them to triangles.

RNApipeline.volcano.plot <- function(datadf, alphavalue = 0.05, lfcLim = 1.5, topgenes = 10, genesetFile = NULL, graphname = "volcano_",
                                     xlimsPercentile = 0.001, ylimsPercentile = 0.001, width = 6, height = 6) {
  
  datadf$GeneSymbol <- as.character(datadf$GeneSymbol)
  datadf$padj <- p.adjust(datadf$pvalue, method = "BH")
  datadf <- na.omit(datadf)
  
  #Filters significant genes.
  input <- mutate(datadf, sig = ifelse(datadf$padj < alphavalue & abs(datadf$log2FoldChange) >= lfcLim, "Sig", "Not_Sig"))
  input$label <- ""
  
  #This section was deleted, because we don't have a genesetFile.
  #
  # if (is.null(genesetFile) == F) {
  # 
  #   geneset <- read.table(genesetFile, stringsAsFactors = F)
  # 
  #   geneset$rownum <- match(geneset[,1], datadf$GeneSymbol)
  # 
  #   geneset <- na.omit(geneset)
  # 
  #   input[geneset[,2],length(input)] <- as.character(geneset[,1])
  # 
  # } else if (topgenes > 0 && is.null(genesetFile) == T) {
  # 
  #   input$label[1:topgenes] <- input$GeneSymbol[1:topgenes]
  # 
  # }
  # 
  # # determines x and y limits
  # 
  # upperFDR <- ceiling(-log(quantile(input$padj, ylimsPercentile), 10))
  # 
  # upperlfc <- max(abs(ceiling(quantile(input$log2FoldChange, xlimsPercentile))), ceiling(quantile(input$log2FoldChange, (1-xlimsPercentile))))
  
  #I make "groups", to add color condition for upregulated and downregulated genes later.
  input$color <- ifelse(input$padj < alphavalue & input$log2FoldChange > lfcLim, "Upregulated",
                        ifelse(input$padj < alphavalue & input$log2FoldChange < -lfcLim, "Downregulated", "Not_Sig"))

  #I select top 10 upregulated and downregulated genes among significant ones, for labeling.
  significant_genes <- input[input$sig == "Sig", ]
  top_upregulated <- head(significant_genes[order(-significant_genes$log2FoldChange), ], n = min(10, sum(significant_genes$log2FoldChange > 0)))
  top_downregulated <- head(significant_genes[order(significant_genes$log2FoldChange), ], n = min(10, sum(significant_genes$log2FoldChange < 0)))

  #I ensure that the input is sorted by GeneID, for correct labeling.
  input <- input[order(input$GeneID), ]

  #I assign labels to top 10 upregulated and downregulated genes.
  input$label[match(top_upregulated$GeneID, input$GeneID)] <- top_upregulated$GeneSymbol
  input$label[match(top_downregulated$GeneID, input$GeneID)] <- top_downregulated$GeneSymbol

  #I determine x and y limits.
  upperFDR <- 50 # Manually setting the upper limit for FDR to 50
  upperlfc <- max(abs(ceiling(quantile(input$log2FoldChange, xlimsPercentile))), ceiling(quantile(input$log2FoldChange, (1 - xlimsPercentile))))
  
  xlims <- c(-upperlfc, upperlfc)
  ylims <- c(0, upperFDR)
  
  #Changes outliers to triangles.
  input$shape <- ifelse(-log10(input$padj) > ylims[2] | abs(input$log2FoldChange) > xlims[2], "triangle", "circle")
  input$padj[-log10(input$padj) > ylims[2]] <- 10^-(ylims[2])
  input$log2FoldChange[input$log2FoldChange > xlims[2]] <- xlims[2]
  input$log2FoldChange[input$log2FoldChange < -xlims[2]] <- -xlims[2]
  
  #Begins plotting.
  v <- ggplot(input, aes(log2FoldChange, -log10(padj), color = color, shape = shape)) # Volcano plot with log2Foldchange versus pvalue
  
  v <- v + geom_point() + # Add points colored by significance
    scale_color_manual(values = c("Not_Sig" = "grey50", "Upregulated" = "red", "Downregulated" = "blue")) + 
    xlim(xlims) + ylim(ylims) +
    xlab("log2(fold change)") + ylab("-log10(FDR)") + ggtitle(graphname) + theme_bw() + 
    theme(legend.position = "none", axis.text = element_text(size = 14), axis.title = element_text(size = 16, face = "bold")) +
    geom_text_repel(data = input[input$label != "", ], aes(label = label), box.padding = 0.5, size = 5, force = 10, segment.size = 0.1, min.segment.length = 0.01, segment.alpha = 0.5, max.overlaps = 100000) # Adding text for the top genes
  
  print(v) # Prints ggplot object after adding layers
  
  ggsave(paste0(graphname, "_VolcanoPlot.pdf"), plot = v, width = width, height = height)
  
  return(list(top_upregulated = top_upregulated, top_downregulated = top_downregulated))
}

```


# Graded homework
# In the paper, some code is provided to generate these figures, but you will have to modify it (the key aspect is to use DESeq2 in R). Provide a brief explanation of each computational step. 

1) Using a counts matrix provided to you, replicate Ex. Data Fig. 4a-b.

2)Once you have done this, colour the upregulated genes (FDR<0.05, log2fc > 1.5) red and the downregulated genes (FDR<0.05, log2fc 
< 1.5) blue.

3)Additionally, Instead of the krige amino acid deprivation gene set, label the top ten most upregulated and top ten most downregulated genes.

```{r}
knitr::include_graphics("C:/Users/norar/OneDrive/Documentos/EPFL/BA/Genomics and bioinformatics/Project/ex4.png")
```


```{r}

results <- RNAseq.Pipeline(conditionsfile_path, RNAcountFile_path)
top_upregulated_genes <- results$upregulated
top_downregulated_genes <- results$downregulated

```

4)Suggested supplementary figures and analysis. Perform at least one of the following analysis. You may reproduce more for bonus points: 

• Instead of performing differential gene expression (DGE) with DESeq2, use edgeR to 
normalise the gene counts matrix, perform DGE using the limma package, and visualise the 
resulting volcano plot. Explain any differences you see, justifying them by referring to the 
differing approaches of DESeq2 and limma. 

```{r}

#Purpose: Main function to execute the RNA-seq analysis pipeline. 
#Parameters:
#conditionsfile: Path to the conditions file containing metadata for the samples.
#RNAcountFile: Pre-analyzed RNA count data file.
#pca: (Default: TRUE) Flag to perform PCA.

RNAseq.Pipeline_edgeR<-function(conditionsfile_path, RNAcountFile_path, pca = TRUE) {
  
  #  I deleted this section because we know for sure that we have a RNAcountFile, therefore it's not necessary.
  # 
  #  if (is.null(RNAcountFile) == TRUE) {   #allows running pipeline on pre-analyzed count data.
  # 
  #   rnaData <- RNApipeline.salmon.process()   
  # 
  #   rnaData <- read.table("salmongene_counts.txt", sep = "\t", header = T)
  # 
  # } else {
  # 
  #   rnaData <- read.table(RNAcountFile, sep = "\t", header = T)
  # 
  # }
  
  #Processes quant.sf files to counts.
  rnaData <- read.csv(RNAcountFile_path, header = TRUE)
  
  #Checks for duplicated genes in the counts file, deletes the following entries if found.
  duplicatedGenes <- which(duplicated(rnaData[,1]) == T)
  if (length(duplicatedGenes) > 0) {
    print("Duplicate ENSGs. Deleted entries:")
    print(rnaData[duplicatedGenes,1:2])
    rnaData <- rnaData[-duplicatedGenes,]
  }
  
  rownames(rnaData) <- rnaData[,1]   #makes rownames the unique ensembl gene ID
  geneKey <- rnaData[,1:2]
  
  # I deleted this section because again we have a RNAcountFile, and we don't have OutputFileName for defining listAnalysis.
  #
  # reorganizes data, makes pca groups table, and makes PCA graph
  # 
  # if (pca == TRUE && is.null(RNAcountFile) == TRUE) {
  # 
  #   PCAdata <- read.table("salmongene_abundance.txt", sep = "\t", header = T)
  # 
  #   PCAdata <- PCAdata[,-1:-2]
  # 
  #   RNAsamples <- colnames(PCAdata)
  # 
  #   labelsdf <- t(as.data.frame(strsplit(RNAsamples, "_")))
  # 
  #   PCAsamples <- paste(labelsdf[,3], labelsdf[,4], labelsdf[,5], sep = "_")
  # 
  #   colnames(PCAdata) <- PCAsamples
  # 
  #   PCAconditions <- data.frame(Samples = PCAsamples, 
  # 
  #                               Condition = factor(paste(labelsdf[,2], labelsdf[,3], sep = "_")))
  # 
  #   RNApipeline.pca(PCAdata, PCAconditions)
  # 
  # }
  # 
  # conditionsdf <- read.table(conditionsfile, sep = "\t", header = T)
  # determines number of analyses for deseq loop
  # listAnalysis <- levels(conditionsdf$OutputFileName)
  
  
  #Differential expression analysis begins here.
  
  conditionsdf <- read.csv(conditionsfile_path, header = T)
  
  #Determines number of analyses for deseq loop, we don't have OutputFileName, so:
  listAnalysis <- unique(conditionsdf$time)
  
  #I took the "untreated" outside of the loop, because it was printing the same thing twice.
  untreatedSamples <- conditionsdf$sample[conditionsdf$time == "0H"]
  untreatedCols <- match(untreatedSamples, colnames(rnaData))
  print(paste("untreatedCols", toString(untreatedCols)))
  
  #I initialize the dataframes to store top genes, for later usage.
  top_upregulated_genes_df <- data.frame()
  top_downregulated_genes_df <- data.frame()
  
  #This loop performs all the differential analysis specified in the conditions file.
  for (i in listAnalysis[-1]) {
    
    #Gets RNAdata columns for samples in the i-th analysis (6H or 72H).
    
    treatedSamples <- conditionsdf$sample[conditionsdf$time == i]
    treatedCols <- match(treatedSamples, colnames(rnaData))
    print(paste("treatedCols", toString(treatedCols)))
    
    
    #Creates a RNA data subset dataframe for each analysis.
    tempRNAdata <- as.matrix(subset(rnaData, select = c(treatedCols, untreatedCols)))
    
    #I deleted these lines because we don't have OutputFileName and the colnames don't match ours.
    #
    # conditions <- conditionsdf[which(conditionsdf$OutputFileName == i),1:2]
    # 
    # conditions <- conditions[match(colnames(tempRNAdata), conditions$Sample),]
    # 
    # colnames(conditions) <- c("sample", "condition")

    
    #I prepare conditions file for edgeR. I want to keep first and fourth columns, first is sample and fourth time.
    conditions <- conditionsdf[which(conditionsdf$time == i | conditionsdf$time == "0H"),c(1,4)] 
    conditions <- conditions[match(colnames(tempRNAdata), conditions$sample),]
    print(conditions)
    colnames(conditions) <- c("sample", "time")
    
    
    #Performs differential expression using edgeR, this is the only difference from the first exercise.
    RNAlfc <- RNApipeline.edgeR.limma(tempRNAdata, conditions, geneKey)
    print(RNAlfc)
    
    #These lines are commented out in this part, because we don't need a rnk file.
    #
    #writes LFC and gsea files
    # write.table(RNAlfc, paste(i, ".txt", sep = ""), sep = "\t", col.names = T, row.names = F, quote = F)
    # 
    # write.table(subset(RNAlfc, select = c(2,4)), paste(i, "_GSEA.rnk", sep = ""), sep = "\t", col.names = F, row.names = F, quote = F)

    #Makes volcano plot.
    top_genes <- RNApipeline.volcano.plot_edgeR(RNAlfc, alphavalue = 0.05, graphname = paste("volcano_", i, "h_vs_0h", sep = ""), topgenes = 20)
    
    #Appends results to top genes dataframes.
    top_upregulated_genes_df <- rbind(top_upregulated_genes_df, 
                                      data.frame(time = paste0(i, "h"), top_genes$top_upregulated))
    top_downregulated_genes_df <- rbind(top_downregulated_genes_df, 
                                        data.frame(time = paste0(i, "h"), top_genes$top_downregulated))
  }
  
  #Returns the lists of top genes.
  return(list(upregulated = top_upregulated_genes_df, downregulated = top_downregulated_genes_df))
    
}

#These functions weren't used, because we didn't need them: RNApipeline.salmon.process<-function(), or RNApipeline.pca<-function(pcaData, pcaGroups)

```

```{r}

# Load required libraries.
library(edgeR)
library(limma)


RNApipeline.edgeR.limma <- function(tempRNAdata, conditions, geneKey) {
  
  #Converts the conditions (time) to factors.
  conditions$time <- factor(conditions$time)
  print(conditions$time)
  
  #Creates a DGEList object.
  dge <- DGEList(counts = tempRNAdata)
  
  #Prefiltering removes low count features of < 10 reads for a row of a feature.
  keep <- rowSums(dge$counts) >= 10
  dge <- dge[keep, , keep.lib.sizes=FALSE]
  
  #I normalize the data.
  dge <- calcNormFactors(dge)
  
  #I create a design matrix.
  design <- model.matrix(~ conditions$time)
  
  #I estimate dispersion.
  dge <- estimateDisp(dge, design)
  
  #I fit the linear model using the limma package.
  v <- voom(dge, design)
  fit <- lmFit(v, design)
  fit <- eBayes(fit)
  
  res <- topTable(fit, coef = 2, number = Inf, sort.by = "P")
  
  #Finally, I prepare the results in a similar format to DESeq2 output.
  res <- data.frame(GeneID = rownames(res), 
                    GeneSymbol = geneKey[match(rownames(res), geneKey$GeneID), "GeneSymbol"], log2FoldChange = res$logFC, 
                    pvalue = res$P.Value, 
                    padj = res$adj.P.Val)
  
  #I order the results by p-value.
  resOrdered <- res[order(res$pvalue),]
  
  return(resOrdered)
}

```

```{r}

# Makes volcanoplot.
# limsPercentile uses input percentile to tag outliers and convert them to triangles.

RNApipeline.volcano.plot_edgeR <- function(datadf, alphavalue = 0.05, lfcLim = 1.5, topgenes = 10, genesetFile = NULL, graphname = "volcano_",
                                     xlimsPercentile = 0.001, ylimsPercentile = 0.001, width = 6, height = 6) {
  
  datadf$GeneSymbol <- as.character(datadf$GeneSymbol)
  datadf$padj <- p.adjust(datadf$pvalue, method = "BH")
  datadf <- na.omit(datadf)
  
  #Filters significant genes.
  input <- mutate(datadf, sig = ifelse(datadf$padj < alphavalue & abs(datadf$log2FoldChange) >= lfcLim, "Sig", "Not_Sig"))
  input$label <- ""
  
  #This section was deleted, because we don't have a genesetFile.
  #
  # if (is.null(genesetFile) == F) {
  # 
  #   geneset <- read.table(genesetFile, stringsAsFactors = F)
  # 
  #   geneset$rownum <- match(geneset[,1], datadf$GeneSymbol)
  # 
  #   geneset <- na.omit(geneset)
  # 
  #   input[geneset[,2],length(input)] <- as.character(geneset[,1])
  # 
  # } else if (topgenes > 0 && is.null(genesetFile) == T) {
  # 
  #   input$label[1:topgenes] <- input$GeneSymbol[1:topgenes]
  # 
  # }
  # 
  # # determines x and y limits
  # 
  # upperFDR <- ceiling(-log(quantile(input$padj, ylimsPercentile), 10))
  # 
  # upperlfc <- max(abs(ceiling(quantile(input$log2FoldChange, xlimsPercentile))), ceiling(quantile(input$log2FoldChange, (1-xlimsPercentile))))
  
  #I make "groups", to add color condition for upregulated and downregulated genes later.
  input$color <- ifelse(input$padj < alphavalue & input$log2FoldChange > lfcLim, "Upregulated",
                        ifelse(input$padj < alphavalue & input$log2FoldChange < -lfcLim, "Downregulated", "Not_Sig"))

  #I select top 10 upregulated and downregulated genes among significant ones, for labeling.
  significant_genes <- input[input$sig == "Sig", ]
  top_upregulated <- head(significant_genes[order(-significant_genes$log2FoldChange), ], n = min(10, sum(significant_genes$log2FoldChange > 0)))
  top_downregulated <- head(significant_genes[order(significant_genes$log2FoldChange), ], n = min(10, sum(significant_genes$log2FoldChange < 0)))

  #I ensure that the input is sorted by GeneID, for correct labeling.
  input <- input[order(input$GeneID), ]

  #I assign labels to top 10 upregulated and downregulated genes.
  input$label[match(top_upregulated$GeneID, input$GeneID)] <- top_upregulated$GeneSymbol
  input$label[match(top_downregulated$GeneID, input$GeneID)] <- top_downregulated$GeneSymbol

  #I determine x and y limits.
  upperFDR <- 5 # Manually setting the upper limit for FDR to 5, the only difference from the volcano plot code of the previous exercise.
  upperlfc <- max(abs(ceiling(quantile(input$log2FoldChange, xlimsPercentile))), ceiling(quantile(input$log2FoldChange, (1 - xlimsPercentile))))
  
  xlims <- c(-upperlfc, upperlfc)
  ylims <- c(0, upperFDR)
  
  #Changes outliers to triangles.
  input$shape <- ifelse(-log10(input$padj) > ylims[2] | abs(input$log2FoldChange) > xlims[2], "triangle", "circle")
  input$padj[-log10(input$padj) > ylims[2]] <- 10^-(ylims[2])
  input$log2FoldChange[input$log2FoldChange > xlims[2]] <- xlims[2]
  input$log2FoldChange[input$log2FoldChange < -xlims[2]] <- -xlims[2]
  
  #Begins plotting.
  v <- ggplot(input, aes(log2FoldChange, -log10(padj), color = color, shape = shape)) # Volcano plot with log2Foldchange versus pvalue
  
  v <- v + geom_point() + # Add points colored by significance
    scale_color_manual(values = c("Not_Sig" = "grey50", "Upregulated" = "red", "Downregulated" = "blue")) + 
    xlim(xlims) + ylim(ylims) +
    xlab("log2(fold change)") + ylab("-log10(FDR)") + ggtitle(graphname) + theme_bw() + 
    theme(legend.position = "none", axis.text = element_text(size = 14), axis.title = element_text(size = 16, face = "bold")) +
    geom_text_repel(data = input[input$label != "", ], aes(label = label), box.padding = 0.5, size = 5, force = 10, segment.size = 0.1, min.segment.length = 0.01, segment.alpha = 0.5, max.overlaps = 100000) # Adding text for the top genes
  
  print(v) # Prints ggplot object after adding layers
  
  ggsave(paste0(graphname, "_VolcanoPlot.pdf"), plot = v, width = width, height = height)
  
  return(list(top_upregulated = top_upregulated, top_downregulated = top_downregulated))
}

```

```{r}

RNAseq.Pipeline_edgeR(conditionsfile_path, RNAcountFile_path)

```

• To explore other ways to visualise differentially expressed genes, generate a heatmap using 
the pheatmap package that contains all the genes for the controls, samples at 6h and 
samples at 72h. How does the figure change if you only include just the upregulated (p<0.05, 
log2fc > 1.5) and downregulated genes (p<0.05, log2fc < 1.5)?

```{r}

#Load necessary libraries.
library(pheatmap)

#I first get my counts matrix.
counts_matrix <- RNAcountfile

#I combine top downregulated and upregulated genes for 72H vs 0H, the only ones I will represent.
top_20_genes_72h <- unique(c(top_downregulated_genes[top_downregulated_genes$time == "72Hh", "GeneID"],
                             top_upregulated_genes[top_upregulated_genes$time == "72Hh", "GeneID"]))

#I filter the entire counts matrix for these top 20 genes.
filtered_counts <- counts_matrix %>%
  filter(GeneID %in% top_20_genes_72h)

#I get the gene expression data.
gene_expression <- filtered_counts %>%
  select(-GeneID, -GeneSymbol)

#I normalize the data using a simple normalization method (e.g., dividing by the column sum and multiplying by 1e6).
normalized_data <- sweep(gene_expression, 2, colSums(gene_expression), FUN = "/") * 1e6

#I need to log-transform the data.
log_transformed_data <- log2(normalized_data + 1)

#Finally I calculate Z-scores for the log-transformed data.
z_scores <- t(scale(t(log_transformed_data)))

#I set the row names to gene symbols for better readability in heatmap.
rownames(z_scores) <- filtered_counts$GeneSymbol

#Generates the heatmap using pheatmap.
pheatmap(z_scores, 
         cluster_rows = TRUE, 
         cluster_cols = TRUE, 
         display_numbers = FALSE, 
         main = "Heatmap of Z-scores for Top Genes at 72 Hours",
         color = colorRampPalette(c("blue", "white", "red"))(50))

```

• Use the same code in the paper to generate a GSEA.rnk file (a list of the genes ranked from 
largest to smallest log fold change). Use the GSEA software (https://www.gsea
msigdb.org/gsea/downloads.jsp) to analyse this list and generate Figures 4c-d. Explain briefly 
what the GSEA software does, and how does it share new insights into differentially 
expressed genes. 

```{r}

knitr::include_graphics("C:/Users/norar/OneDrive/Documentos/EPFL/BA/Genomics and bioinformatics/Project/ex4cd.png")

```
```{r}

#Purpose: Main function to execute the RNA-seq analysis pipeline. 
#Parameters:
#conditionsfile: Path to the conditions file containing metadata for the samples.
#RNAcountFile: Pre-analyzed RNA count data file.
#pca: (Default: TRUE) Flag to perform PCA.

RNAseq.Pipeline_GSEA<-function(conditionsfile_path, RNAcountFile_path, pca = TRUE) {
  
  #  I deleted this section because we know for sure that we have a RNAcountFile, therefore it's not necessary.
  # 
  #  if (is.null(RNAcountFile) == TRUE) {   #allows running pipeline on pre-analyzed count data.
  # 
  #   rnaData <- RNApipeline.salmon.process()   
  # 
  #   rnaData <- read.table("salmongene_counts.txt", sep = "\t", header = T)
  # 
  # } else {
  # 
  #   rnaData <- read.table(RNAcountFile, sep = "\t", header = T)
  # 
  # }
  
  #Processes quant.sf files to counts.
  rnaData <- read.csv(RNAcountFile_path, header = TRUE)
  
  #Checks for duplicated genes in the counts file, deletes the following entries if found.
  duplicatedGenes <- which(duplicated(rnaData[,1]) == T)
  if (length(duplicatedGenes) > 0) {
    print("Duplicate ENSGs. Deleted entries:")
    print(rnaData[duplicatedGenes,1:2])
    rnaData <- rnaData[-duplicatedGenes,]
  }
  
  rownames(rnaData) <- rnaData[,1]   #makes rownames the unique ensembl gene ID
  geneKey <- rnaData[,1:2]
  
  # I deleted this section because again we have a RNAcountFile, and we don't have OutputFileName for defining listAnalysis.
  #
  # reorganizes data, makes pca groups table, and makes PCA graph
  # 
  # if (pca == TRUE && is.null(RNAcountFile) == TRUE) {
  # 
  #   PCAdata <- read.table("salmongene_abundance.txt", sep = "\t", header = T)
  # 
  #   PCAdata <- PCAdata[,-1:-2]
  # 
  #   RNAsamples <- colnames(PCAdata)
  # 
  #   labelsdf <- t(as.data.frame(strsplit(RNAsamples, "_")))
  # 
  #   PCAsamples <- paste(labelsdf[,3], labelsdf[,4], labelsdf[,5], sep = "_")
  # 
  #   colnames(PCAdata) <- PCAsamples
  # 
  #   PCAconditions <- data.frame(Samples = PCAsamples, 
  # 
  #                               Condition = factor(paste(labelsdf[,2], labelsdf[,3], sep = "_")))
  # 
  #   RNApipeline.pca(PCAdata, PCAconditions)
  # 
  # }
  # 
  # conditionsdf <- read.table(conditionsfile, sep = "\t", header = T)
  # determines number of analyses for deseq loop
  # listAnalysis <- levels(conditionsdf$OutputFileName)
  
  
  #Differential expression analysis begins here.
  
  conditionsdf <- read.csv(conditionsfile_path, header = T)
  
  #Determines number of analyses for deseq loop, we don't have OutputFileName, so:
  listAnalysis <- unique(conditionsdf$time)
  
  #I took the "untreated" outside of the loop, because it was printing the same thing twice.
  untreatedSamples <- conditionsdf$sample[conditionsdf$time == "0H"]
  untreatedCols <- match(untreatedSamples, colnames(rnaData))
  print(paste("untreatedCols", toString(untreatedCols)))
  
  #I initialize the dataframes to store top genes, for later usage.
  top_upregulated_genes_df <- data.frame()
  top_downregulated_genes_df <- data.frame()
  
  #This loop performs all the differential analysis specified in the conditions file.
  for (i in listAnalysis[-1]) {
    
    #Gets RNAdata columns for samples in the i-th analysis (6H or 72H).
    
    treatedSamples <- conditionsdf$sample[conditionsdf$time == i]
    treatedCols <- match(treatedSamples, colnames(rnaData))
    print(paste("treatedCols", toString(treatedCols)))
    
    
    #Creates a RNA data subset dataframe for each analysis.
    tempRNAdata <- as.matrix(subset(rnaData, select = c(treatedCols, untreatedCols)))
    
    #I deleted these lines because we don't have OutputFileName and the colnames don't match ours.
    #
    # conditions <- conditionsdf[which(conditionsdf$OutputFileName == i),1:2]
    # 
    # conditions <- conditions[match(colnames(tempRNAdata), conditions$Sample),]
    # 
    # colnames(conditions) <- c("sample", "condition")

    
    #I prepare conditions file for DESeq2. I want to keep first and fourth columns, first is sample and fourth time.
    conditions <- conditionsdf[which(conditionsdf$time == i | conditionsdf$time == "0H"),c(1,4)] 
    conditions <- conditions[match(colnames(tempRNAdata), conditions$sample),]
    print(conditions)
    colnames(conditions) <- c("sample", "time")
    
    
    #Performs differential expression.
    RNAlfc <- RNApipeline.DESeq2(tempRNAdata, conditions, geneKey)
    print(RNAlfc)
    
    #ONLY NEW THING: I use this line I had deleted to obtain the rnk files.
    write.table(subset(RNAlfc, select = c(2,4)), paste(i, "_GSEA.rnk", sep = ""), sep = "\t", col.names = F, row.names = F, quote = F)

    #Makes volcano plot.
    top_genes <- RNApipeline.volcano.plot(RNAlfc, alphavalue = 0.05, graphname = paste("volcano_", i, "h_vs_0h", sep = ""), topgenes = 20)
    
    #Appends results to top genes dataframes.
    top_upregulated_genes_df <- rbind(top_upregulated_genes_df, 
                                      data.frame(time = paste0(i, "h"), top_genes$top_upregulated))
    top_downregulated_genes_df <- rbind(top_downregulated_genes_df, 
                                        data.frame(time = paste0(i, "h"), top_genes$top_downregulated))
  }
  
  #Returns the lists of top genes.
  return(list(upregulated = top_upregulated_genes_df, downregulated = top_downregulated_genes_df))
    
}

#These functions weren't used, because I didn't need them: RNApipeline.salmon.process<-function(), or RNApipeline.pca<-function(pcaData, pcaGroups)

```

```{r}

RNAseq.Pipeline_GSEA(conditionsfile_path, RNAcountFile_path)

```
